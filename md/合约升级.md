# 可升级合约（Proxy）速查

这份笔记概述了可升级合约的核心机制、前端交互方式、部署顺序、初始化策略，以及存储布局与升级约束，便于快速对照与实战落地。

---

## 核心路由机制：fallback + delegatecall

- 前端把交易发到 `proxy` 地址；`proxy` 不认识的方法会触发 `fallback`，把原始 calldata 原样 `delegatecall` 到当前实现合约（implementation）。
- 代码在实现合约的上下文执行，但读写“代理”的存储，因此升级只换代码不换数据。

示意（与工程内 `upgrade/Proxy.sol` 一致的关键逻辑）：

```solidity
fallback() external payable {
    address _impl = implementation;
    require(_impl != address(0), "Implementation not set");
    assembly {
        calldatacopy(0, 0, calldatasize())
        let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)
        returndatacopy(0, 0, returndatasize())
        switch result
        case 0 { revert(0, returndatasize()) }
        default { return(0, returndatasize()) }
    }
}
```

要点：

- `msg.sender` 在 `delegatecall` 下保持为外部调用者，权限判断不会错位。
- 事件从 `proxy` 地址发出。
- 若函数在 `proxy` 自身存在（如 `upgradeTo`），不会走 `fallback`，而是在 `proxy` 上本地执行。
- `delegatecall`保证交互的数据保存在proxy合约，合约升级时不会丢失数据

---

## 与前端交互（ABI/地址）

- 交互地址：始终使用 `proxy` 地址。
- ABI：业务交互用“实现合约”的 ABI；若需要调用升级/管理方法，再准备一份包含 `upgradeTo`/`upgradeToAndCall` 等管理 ABI（同一地址，不同 ABI）。

示例（ethers.js）：

```ts
const proxyAddress = "0x...";
const logicAbi = [ /* LogicV1 ABI */ ];
const adminAbi = [ "function upgradeTo(address newImplementation)" ];

const logic = new ethers.Contract(proxyAddress, logicAbi, signer);      // 业务
const proxyAdmin = new ethers.Contract(proxyAddress, adminAbi, signer); // 管理

await logic.initialize();
await logic.setValue(123);
await proxyAdmin.upgradeTo("0xNewImpl...");
```

---

## 部署顺序（首发）

通用流程（Transparent 模式为例）：

1) 部署 `ProxyAdmin`（可选但推荐，用于集中管理多个代理）。
2) 部署实现合约 `LogicV1`。
3) 部署 `Proxy`，构造参数携带：
   - `implementation = LogicV1` 地址
   - `admin = ProxyAdmin` 或管理员 EOA 地址
   - `data = abi.encodeCall(LogicV1.initialize, (args...))`（部署即初始化，单笔交易原子完成）

通常写LogicV1合约时，就需要考虑合约未来是否有升级需求，如有，需部署`LogicV1`和`Proxy`，使用`Proxy`与前端交互，保证后续部署`LogicV2`能正常升级，若没有升级需求，可使用`LogicV1`与前端交互。

---

## initialize vs constructor（为何升级模式避免 constructor）

- 在代理模式下，构造函数运行在“实现合约本体”上，写不到“代理存储”；因此不能用 constructor 初始化代理内的状态。
- 应提供一次性的初始化函数（约定命名 `initialize`，也可自定义名称），并在部署代理时通过 `_data` 原子调用它。
- 可能合约的owner不是合约部署人员(开发者)，所以使用initialize设置合约owner
- 推荐使用 OpenZeppelin `Initializable` 的 `initializer`/`reinitializer` 修饰符，保证只调用一次；并在实现合约的 constructor 中调用 `_disableInitializers()`，防止实现本体被误初始化。

示例：

```solidity
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract LogicV1 is Initializable {
    uint256 public value;
    address public owner;

    function initialize(address _owner) public initializer {
        owner = _owner;
    }
}
```

---

## 存储布局与升级约束（为何不能删/改/重排变量）

- 升级只替换代码，不迁移数据；必须维持“存储槽位布局”兼容。
- 规则：
  - 变量只能在末尾追加。
  - 不要删除、重命名（可改为 `_deprecatedX`）、重排或修改已存在变量的类型。
  - 预留扩展位：`uint256[50] private __gap;`

错误 vs 正确：

```solidity
// V1
uint256 a; // slot0
uint256 b; // slot1

// V2（错误：删了 a，导致 b 前移到 slot0，数据串位）
// uint256 a; // removed
uint256 b; // 变成 slot0

// V2（正确：保留 a 占位，只在末尾追加新变量）
uint256 a; // deprecated
uint256 b; // slot1 不变
uint256 c; // 新增 slot2
```

---

## 升级流程（到 LogicV2）

1) 部署新实现 `LogicV2`。
2) 执行升级：
   - Transparent：`ProxyAdmin.upgrade` 或 `upgradeAndCall`（初始化新增状态）。
   - UUPS：通过代理地址调用实现合约的 `upgradeTo`/`upgradeToAndCall`。
3) 若新增状态需要初始化，使用 `...AndCall` 或 `reinitializer(n)`。

---

## 最佳实践与常见坑

- 使用 EIP-1967 固定槽位存储 `implementation`/`admin`，或直接采用 OpenZeppelin 的 `TransparentUpgradeableProxy`/`ERC1967Proxy`，避免“存储碰撞”。
- 部署即初始化：把 `initialize(...)` 的调用打包到代理构造中，避免“先到先得”被抢初始化。
- 权限治理：升级入口仅对管理员开放；业务函数使用 `onlyOwner` 或基于角色的访问控制。
- 前端：
  - 业务调用＝`proxy` 地址 + 实现 ABI。
  - 管理调用＝`proxy` 地址 + 管理 ABI。
  - 监听事件以 `proxy` 地址为准。
- 版本演进：弃用旧方法时可保留函数体并 `revert("Deprecated")` 或内部转调新方法；避免破坏性升级。

---

## UUPS vs Transparent 对比与流程

- 核心区别：

  - **升级入口**：Transparent 在代理合约（由 `ProxyAdmin` 调用 `upgrade`）；UUPS 在实现合约（`upgradeTo/upgradeToAndCall`），实现内用 `_authorizeUpgrade` 控制权限。
  - **权限主体**：Transparent 的管理员是 `ProxyAdmin` 的 `owner`；UUPS 的管理员通常是实现合约里的 `owner`/角色。
  - **透明化保护**：Transparent 对管理员调用走“管理路径”，不触发业务 `fallback`；UUPS 无透明化，靠实现权限控制。
  - **代码/成本**：Transparent 代理较胖且多一个 `ProxyAdmin`；UUPS 代理极瘦，升级逻辑在实现里，总体更省 gas。
  - **风险侧重点**：Transparent 升级能力更不易被新实现破坏；UUPS 要求每版实现都正确保留升级函数与授权，避免砖化。

- 首次部署：

  - **Transparent**：部署实现 `LogicV1` → 部署 `ProxyAdmin` → 部署 `TransparentUpgradeableProxy(impl, admin=ProxyAdmin, data=encodeCall(initialize))`。
  - **UUPS**：部署实现 `LogicV1Upgradeable` → 部署 `ERC1967Proxy(impl, data=encodeCall(initialize))`（或用插件 `deployProxy(..., { kind: 'uups' })`）。

- 升级到 V2：

  - **Transparent**：部署 `LogicV2` → 由 `ProxyAdmin.upgrade(AndCall)` 切换实现；如需初始化新增状态，使用 `upgradeAndCall`。
  - **UUPS**：部署 `LogicV2Upgradeable` → 通过代理地址调用实现的 `upgradeTo(AndCall)`（或插件 `upgradeProxy`），可选 `reinitializer(n)` 初始化新增状态。

- 前端交互：两者都始终用“代理地址 + 实现 ABI”，升级后地址不变；若新增方法则更新 ABI。

---

## 额外说明（当前示例代码的碰撞风险）

在示例 `upgrade/Proxy.sol` 中，`implementation`/`admin` 直接占用 slot0/1；而 `LogicV1` 的 `value`/`owner` 也会从 slot0 开始。`delegatecall` 后会把 `value` 写到 slot0，覆盖 `implementation` 地址，造成严重存储碰撞。切换到 EIP-1967 槽位或使用 OpenZeppelin 标准代理可彻底规避此问题。
